---
title: "History Matching (HM) LMDZ SCM output"
output: html_document
---

```{r, echo = FALSE}
knitr::opts_chunk$set(fig.path='figure/historymatchlmdz/', 
                      fig.height=6, fig.width=10,
                      cache.path='_knitr_cache/historymatch-lmdz/')
set.seed(14112017)
```

In this example we use R and Stan files from `BuildEmulator` and `HistoryMatching` directories to construct GP emulator and perform two consecutive waves of history matching. First we start with loading the necessary packages, functions and compilation of Stan files that are used to construct a GP emulator and perform history macthing.

```{r results='hide', message=FALSE, warning=FALSE}
setwd('..')
source('BuildEmulator/BuildEmulator.R')
source('HistoryMatching/HistoryMatching.R')
```

We proceed to loading the data file `lmdzAWave1.RData` that contains the computer model simulations. The computer model inputs are saved in columns 1 to 6 (on $[-1, 1]$ scale) of the object `tData` together with the simulator response saved as a last
column of a data frame.

The values of observations, `tObs`, and the variance of the observation errors, `tObsErr`, are saved in the data file `lmdzLES.RData`

```{r}
load('../Demonstrations/lmdzAWave1.RData')
head(tData)
load('../Demonstrations/lmdzLES.RData')
print(tObs)
print(tObsErr)
```

We repeat the same steps decribed in `emulate-lmdz.Rmd` to construct and validate a GP emulator (please see the relevant R Markdown for more details).

Specify a number and a vector of metrics of interest (computer model output), a number and vector of candidates (potential emulator inputs).

```{r}
metric = c('SCMdata')
nmetric = length(metric)
cands = names(tData)[-which(names(tData) == metric)]
param = cands[-which(cands == "Noise")]
nparam = length(param)
```

We produce scatter plots to visualize the model response behaviour against model inputs standardized on $[-1, 1]$ scale via scatter plot.

```{r plot-lmdz-scatterHM}
if(nparam*nmetric<2){ par(mfrow = c(1, 1), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 4){ par(mfrow = c(2, 2), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 9){ par(mfrow = c(3, 3), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 16){ par(mfrow = c(4, 4), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 25){ par(mfrow = c(5,5), mar=c(4, 4, 1, 1)) }
for ( iparam in 1:nparam ) {
  for (j in 1:nmetric) {
    ymin=tObs[j]-sqrt(tObsErr[j])
    ymax=tObs[j]+sqrt(tObsErr[j])
    plot(tData[,iparam],tData[,nparam+j+1],col=2,xlab=cands[iparam],ylab=metric[j],
         ylim=range(tData[,nparam+j+1], ymin, ymax))
    abline(h=c(tObs[j], ymin, ymax), col = 'blue', lty =2, lwd=c(1,3,3))
  }
}
```

## Build and validate the emulator.

We proceed to building a GP emulator. Please review `emulate-lmdz.Rmd` R Markdown for more details.

```{r results='hide', message=FALSE, warning=FALSE}
listnew <-lapply(1:nmetric,function(k) names(tData[1:nparam]))
myem.lm <-InitialBasisEmulators(tData=tData,HowManyEmulators=nmetric,additionalVariables = listnew)
```

Perform diagnostics for GP emulator, in particular, the traceplot diagnostics:

```{r plot-lmdz-traceplotHM}
traceplot(myem.lm[[1]]$StanModel)
```

as well as the Leave One Out (LOO) plots

```{r plot-lmdz-LOOHM}
for (i in 1:nmetric) {
  tLOOs1 <- LOO.plot(StanEmulator = myem.lm[[i]] , ParamNames=names(tData)[1:nparam])
}
```

## Perform Wave 1 of History Matching (HM)

We are ready to proceed to Wave 1 history macthing. We are interested to search for vaues of the model input parameters that lead to `close enough' models (as defined by our uncertainties). In order to rule out implausible regions of input space, we adopt the implausibility function $\mathcal{I}(\boldsymbol{x})$ defined as

$$\mathcal{I}(\boldsymbol{x})=\frac{\vert z-E[f(\boldsymbol{x})]\vert}{\sqrt{Var[e] + Var[\eta] + Var[f(\boldsymbol{x})]}}$$
where $z$ corresponds to `tObs`, $Var[e]$ corresponds to `tObsErr`. The values of $E[f(\boldsymbol{x})]$ and $Var[f(\boldsymbol{x})]$ are generated by using our emulator at unseen $\boldsymbol{x}\in\mathcal{X}$. Currently, the value of $Var[\eta]$ (variance of model discrepancy) has to be pre-specified by the user.

We are interested to obtain the Not Ruled Out Yet (NROY) space, which is the subsetof parameter space, $\mathcal{X}$, for which $\mathcal{I}(\boldsymbol{x})\leq a$, where $a$ (`cutoff`) is a pre-specified threshold. 

Mathematically, NROY space is defined as 

$$\mathcal{X}^1=\Big\{\boldsymbol{x}\in\mathcal{X}: \mathcal{I}(\boldsymbol{x})\leq a \Big\}.$$
We start by generating 10,000 points random LHC (Latin Hypercube), stored in data frame `Xp`, to represent the parameter space $\mathcal{X}$, at which we are planning to compute the implausibility function defined previously.

```{r}
Xp <- as.data.frame(2*randomLHS(10000, nparam)-1)
names(Xp) <- param
head(Xp)
```

Before we proceed to performing history matching we (our collaborators) need to specify the threshold value $a$ (`cutoff`) together with variance of model discrepancy $Var[\eta]$ (`Disc`).

```{r}
Disc = 0
cutoff = 3
```

Let's obtain the implausibility function values at $\boldsymbol{x}\in\mathcal{X}$ (`Xp`):

```{r}
Timps <- ManyImplausibilitiesStan(NewData=Xp, Emulator=myem.lm, Discrepancy=Disc,
                                    Obs=tObs, ObsErr=tObsErr, is.GP=NULL,FastVersion = TRUE)
head(Timps)
```

We are interested in visualizing the results of history matching by generating the implausibility plots.

Firstly, we need to generate the implausibility lists using function `CreateImpList`. For function `CreateImpList` we need to specify `ImpData`, a data frame that contains the input points, `Xp`, and the corresponding values of implausibility function evaluated at `Xp`.

```{r}
ImpData_wave1 = cbind(Xp, Timps)
VarNames <- names(Xp)
valmax = 1
ImpListM1 = CreateImpList(whichVars = 1:nparam, VarNames=VarNames, ImpData=ImpData_wave1, nEms=length(myem.lm), whichMax=valmax)
```


```{r plot-lmdz-implausHM, fig.width=5}
imp.layoutm11(ImpListM1,VarNames,VariableDensity=FALSE,newPDF=FALSE,the.title=paste("InputSpace_wave",WAVEN,".pdf",sep=""),newPNG=FALSE,newJPEG=FALSE,newEPS=FALSE)
```

We managed to produce the NROY density and minimum implausibility plots for 2D projections of the parameters. Each panel on the upper triangle shows the proportion of parameter settings behind each pixel that are NROY. Grey regions are completely ruled out. 

The lower triangle shows minimum implausibility plots. We plot the value of the smallest implausibility found in each pixel. For comparative purposes the plots have the same orientation as those on the upper triangle. Green and yellow areas of this plot would indicate the location of potentially `good' settings of model parameters in case when the emulator performs well. For a second Wave we would look to further explore the green and yellow areas of these plots as these areas correspond to NROY space after Wave 1.

By performing a single Wave of HM we have managed to cut out parameter space and achieve an NROY space of size

```{r}
NROY1 = which(Timps < cutoff)
print(paste('The size of NROY space after Wave 1 HM', length(NROY1)/dim(Xp)[1]*100, "% of original input space"), 
      sep = " ")
```

Post-processing History Matching results:

```{r}
XpNext = Xp[NROY1, ]
NROY.list = list()
Impl.list = list()
Impl.list[[1]] = matrix(Timps, ncol = 1)
NROY.list[[1]] = matrix(NROY1, ncol = 1)
```


## Build an emulator for Wave 2

History matching method is most powerful when refocussing steps are taken, in particular within NROY space a new ensemble is run and the procedure is repeated. 

Mathematically, NROY space in wave $k$ is defined as 

$$\mathcal{X}^k=\big\{\boldsymbol{x}\in\mathcal{X}^{k-1}:\mathcal{I}(\boldsymbol{x}; \boldsymbol{F}_{[k]})\leq a\big\}$$
where $\mathcal{I}(\boldsymbol{x}; \boldsymbol{F}_{[k]})$ is computed by employing an emulator for $f(\boldsymbol{x})$ defined inside $\mathcal{X}^{k-1}$ and obtained based on the design
$$\boldsymbol{X}_{[k]}=\big(\boldsymbol{x}_{k,1}, \dots, \boldsymbol{x}_{k,n} \big)^T\in\mathcal{X}^{k-1}$$
and the computer model evaluations 
$$\boldsymbol{F}_{[k]}=\big(f(\boldsymbol{x}_{k,1}), \dots, f(\boldsymbol{x}_{k,n}) \big)^T$$.


We continue with loading the data file `lmdzAWave2.RData` that contains model simulations for Wave 2. 
```{r}
load('../Demonstrations/lmdzAWave2.RData')
head(tData)
```

Similarly to Wave 1, we produce scatter plots

```{r plot-lmdz-scatterHM2}
if(nparam*nmetric<2){ par(mfrow = c(1, 1), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 4){ par(mfrow = c(2, 2), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 9){ par(mfrow = c(3, 3), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 16){ par(mfrow = c(4, 4), mar=c(4, 4, 1, 1))
} else if(nparam*nmetric <= 25){ par(mfrow = c(5,5), mar=c(4, 4, 1, 1)) }
for ( iparam in 1:nparam ) {
  for (j in 1:nmetric) {
    ymin=tObs[j]-sqrt(tObsErr[j])
    ymax=tObs[j]+sqrt(tObsErr[j])
    plot(tData[,iparam],tData[,nparam+j+1],col=2,xlab=cands[iparam],ylab=metric[j],
         ylim=range(tData[,nparam+j+1], ymin, ymax), xlim = c(-1, 1))
    abline(h=c(tObs[j], ymin, ymax), col = 'blue', lty =2, lwd=c(1,3,3))
  }
}
```

We proceed to constructing a GP emulator.

```{r results='hide', message=FALSE, warning=FALSE}
listnew <-lapply(1:nmetric,function(k) names(tData[1:nparam]))
myem.lm2 <-InitialBasisEmulators(tData=tData,HowManyEmulators=nmetric,additionalVariables = listnew)
```

Prior to using a newly obtained GP emulator for history matching, it is important to validate its performance, using a traceplot:

```{r plot-lmdz-traceplotHM2}
traceplot(myem.lm2[[1]]$StanModel)
```

as well as the Leave One Out (LOO) plots

```{r plot-lmdz-LOOHM2}
for (i in 1:nmetric) {
  tLOOs2 <- LOO.plot(StanEmulator = myem.lm2[[i]] , ParamNames=names(tData)[1:nparam])
}
```

## Perform Wave 2 History Matching (HM)

Before performing second Wave of History Matching we could redefine some of the parameters such as a threshold value $a$ (`cutoff`). Let's compute an implausibility values at the reduced input space $\mathcal{X}^1$ `XpNext`.

```{r}
cutoff = 2
Timps2 = ManyImplausibilitiesStan(NewData=XpNext, Emulator=myem.lm2, Discrepancy=Disc,
                                    Obs=tObs, ObsErr=tObsErr, is.GP=NULL,FastVersion = TRUE)
head(Timps)
```

As before we are interested in visualizing the result of history matching for Wave 2 by generating the implausibility plots.

Firstly, we need to generate the implausibility lists using function `CreateImpListWaveM`. For function `CreateImpListWaveM` we need to specify `ImpData` that contains the implausibility calculations produced at Wave 1 and Wave 2.

```{r}
Impl.list[[2]] = matrix(Timps2, ncol = 1)
NROY.list[[2]] = matrix(which(Timps2 < cutoff), ncol = 1)
ImpData <- ImpDataWaveM(Xp, NROY.list, Impl.list)
ImpListM2 <- CreateImpListWaveM(whichVars = 1:nparam, VarNames=VarNames, ImpData = ImpData,
                              nEms=nmetric, Resolution=c(15,15), whichMax=1)

```

```{r plot-lmdz-implausHM2, fig.width=5}
imp.layoutm11(ImpListM2,VarNames,VariableDensity=FALSE,newPDF=FALSE,the.title=paste("InputSpace_wave",2,".pdf",sep=""),newPNG=FALSE,newJPEG=FALSE,newEPS=FALSE)
```

By performing a second Wave of HM we have managed to cut out parameter space and achieve an NROY space of size

```{r}
NROY2 = which(Timps2 < cutoff)
print(paste('The size of NROY space after Wave 2 HM', length(NROY2)/dim(Xp)[1]*100, "% of original input space"), 
      sep = " ")
```

