---
title: "Experiments with ARPEGE-Climat model"
output: html_document
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      fig.path='figure/CNRM/', 
                      fig.height=6, fig.width=10,
                      cache.path='_knitr_cache/emulatenonstat-CNRM/')
set.seed(14112017)
```

In this vignette, we attempt to provide a quick demo how to generate results of Section 5 of [@volodina2018diagnostic]. 

#### Preliminaries

We start with loading the necessary packages, functions and compilation of ``Stan`` files that are necessary to construct a stationary and nonstationary GP emulators.

```{r results='hide', message=FALSE, warning=FALSE}
setwd('..')
source('BuildEmulator/BuildEmulator.R')
source('BuildEmulator/BuildEmulatorNSt.R')
```

In this Section, we consider the average potential temperature generated by the SCM by varying nine input parameters of interest, all associated with the parameterization of convection. 

Firstly, we identified the physically plausible ranges of the input model parameters with the HIGH-TUNE team and standardazied them to the range $[-1, 1]$, which is the usual practice in constructing emulators for computer experiments. 

```{r}
load('../Demonstrations/cnrmMasterWave1_US.RData')
scaledParams <- cnrmMasterWave1_US
cands <- c(names(scaledParams)[-c(1, 11:14)])

load('../Demonstrations/cnrmWave1.RData')
FullData <- tData 
m = mean(FullData$SCMdata)
s.d = sd(FullData$SCMdata)
FullData$SCMdata <- (FullData$SCMdata - m)/s.d
```

We produce the plots of the average potential temperature against each input. We observe that the average potential temperature varies most with the input `ALFX`, i.e. the variability in the response of the average potential temperature increases as `ALFX` increases. 

```{r fig.width = 8}
par(mfrow = c(3, 3), mar = c(4, 4, 2, 1))
for(i in 1:(length(cands)-1)) {
  plot(FullData[, cands[i]], FullData[, "SCMdata"]*s.d+m, pch = 20, xlab = cands[i], 
       ylab = 'Pot Temp Average')
}
```

We choose first 120 points to train our emulators and the remaining 40 points are used for validation purpose.

```{r}
tData = FullData[1:120, ]
tData.valid =  FullData[121:160,]
head(tData)
```

#### Construct a stationary GP emulator

We construct a stationary GP emulator in two steps. Firstly, we obtain a form of the mean function, i.e. $h(\boldsymbol{x})^T\boldsymbol{\beta}$ by calling a function `myem.lm`:

```{r message = FALSE, warning = FALSE}
myem.lm.cnrm = EMULATE.lm(Response="SCMdata", tData=tData, tcands=cands,
                            tcanfacs=NULL,TryFouriers=TRUE,maxOrder=4,maxdf = 30)
myem.lm.cnrm$linModel

```

After deriving the form of the mean function, we proceed to fitting a stationary GP emulator in `Stan` with squared exponential correlation function.  

```{r message=FALSE, warning=FALSE}
 myem.gp.cnrm = EMULATE.gpstan(meanResponse=myem.lm.cnrm, tData=tData, 
                                additionalVariables=NULL, FastVersion = TRUE, 
                                sigmaPrior = TRUE)

```

#### Diagnostics for a stationary GP emulator.

We proceed to perform a Leave-One-Out diagnostics for a stationary GP emulator. The predictions and two standard deviation prediction intervals are in black. The true values are in green if they lie within two standard deviation prediction intervals, or red otherwise.

```{r message=FALSE, warning=FALSE, fig.width = 8}
clim.st.LOO <- LOO.plot(StanEmulator = myem.gp.cnrm,
                        ParamNames=colnames(myem.gp.cnrm$Design))
```

We also produce plots of standard errors against each input.

```{r message=FALSE, warning=FALSE, fig.width = 8}
std.err <- CalStError(clim.st.LOO, tData$SCMdata)
par(mfrow = c(3, 3), mar = c(4, 4, 2, 1))
for(i in 1:(length(cands)-1)) {
  plot(tData[, cands[i]], std.err, pch = 20, xlab = cands[i], 
       ylab = 'std. error')
}
```

#### Mixture model

After obtaining the standard errors from a stationary fit, we proceed to modelling the mixture components. In ` MIXTURE.design` function, we specify the form of function $g(\boldsymbol{x})$ in `formula`, which is linear with all input terms. We set `L=2`, since we assume that we have two input regions of distinct model behaviour.


```{r}
tData.mixture = as.data.frame(cbind(tData[, cands], std.err))
myem.cnrm.mixture <- MIXTURE.design(formula =std.err~
                              ALFX+TENTRX+TENTR+RKDX+RKDN+VVX+VVN+GAMAP1+REFLCAPE,
                              tData.mixture =tData.mixture, L = 2)

```

```{r fig.width = 8}
mixture.cnrm <- data.frame(cbind(tData[, cands], std.err, 
                                 myem.cnrm.mixture$MixtureMat))
names(mixture.cnrm) <- c(cands, 'std.err', 'red', 'blue')
p1 <- ggplot(mixture.cnrm, aes(x = ALFX, y = std.err, col = rgb(red = red, blue = blue, green = 0), ymin = -3.5, ymax=3.5)) +
  geom_point(size = 2) + scale_color_identity()
p1
```

#### Construct a nonstationary GP model.

We proceed to fit a nonstationary GP model. We use the same form of the linear function as we used for statinary GP model.

```{r}
  myem.gp.cnrm.nst <- EMULATE.gpstanNSt(meanResponse=myem.lm.cnrm, tData=tData, 
                                        additionalVariables=NULL, 
                                        FastVersion = TRUE, mixtureComp=
                                        myem.cnrm.mixture, 
                                        sigmaPrior = TRUE)
```

#### Diagnostics for a nonstationary GP emulator.

Similar to a stationary GP emulator, we proceed to perform LOO diagnstics.

```{r}
LOOs.nst <- LOO.plot.NSt(StanEmulator = myem.gp.cnrm.nst,
                         ParamNames=colnames(myem.gp.cnrm.nst$Design))
```


#### Comparison 

We compare the performance of stationary and nonstationary emulators on a validation set. The posterior mean and two standard deviation prediction intercals produced by emulators are in black. The green and red points are the model values, coloured 'green' if they lie within two standard deviation prediction intervals and 'red' if they lie outside.


```{r}
predict.st <- EMULATOR.gpstan(tData.valid, Emulator = myem.gp.cnrm, FastVersion = FALSE)
predict.nst <- EMULATOR.gpstanNSt(tData.valid, mixtureComp = myem.cnrm.mixture, 
                                  Emulator = myem.gp.cnrm.nst, FastVersion = FALSE)
```

```{r}
predict.st.plot <- cbind(predict.st$Expectation, 
                        predict.st$Expectation - 2*sqrt(predict.st$Variance), 
                        predict.st$Expectation + 2*sqrt(predict.st$Variance))
predict.nst.plot <- cbind(predict.nst$Expectation, 
                        predict.nst$Expectation - 2*sqrt(predict.nst$Variance), 
                        predict.nst$Expectation + 2*sqrt(predict.nst$Variance))
par(mfrow = c(1, 2), mar = c(4, 2, 1, 1))
ValidPlot(predict.st.plot, tData.valid, tData.valid$SCMdata, 
          axis = 1, heading =  "st-GP", xrange = c(-1, 1), 
          ParamNames = cands,
            interval = c(-4, 4))
ValidPlot(predict.nst.plot, tData.valid, tData.valid$SCMdata, 
          axis = 1, heading =  "nst-GP", xrange = c(-1, 1), 
          ParamNames = cands,
            interval = c(-4, 4))
```



